#! /usr/bin/python

# autogenerated on 2020-03-25 09:07

# color image quantization: LBG algorithm

import cv2
import numpy as np

from utils import *


def constrain(value, min_val, max_val):
    for i, v in enumerate(value):
        if v < min_val:
            value[i] = min_val
        elif v > max_val:
            value[i] = max_val
    return value


def add_centroids(centroids, delta):
    output = [None] * (len(centroids) * 2)
    i = 0
    for centr in centroids:
        output[i] = constrain(centr - delta, 0, 255)
        i += 1
        output[i] = constrain(centr + delta, 0, 255)
        i += 1
    return output


def init_centroid(img):
    tmp = np.mean(img, axis=(0, 1)).astype(np.uint8)
    return [tmp]


def assign_pixel(pixel, centroid):
    min_value = np.linalg.norm(pixel - centroid[0])
    min_index = 0
    for i, c in enumerate(centroid[1:], 1):
        val = np.linalg.norm(pixel - c)
        if val < min_value:
            min_index = i
            min_value = val
    return min_index


def assign_image(img, centroid):
    sx, sy, _ = img.shape
    new_store = np.zeros((sx, sy), dtype=np.uint8)
    for i in range(sx):
        for j in range(sy):
            new_store[i, j] = assign_pixel(img[i, j, :], centroid)

    return new_store


def update_centroids(img, store, centroids):
    output = [np.zeros((3)) for _ in centroids]
    count = [0] * len(centroids)
    sx, sy = store.shape
    for i in range(sx):
        for j in range(sy):
            output[store[i, j]] += img[i, j, :]
            count[store[i, j]] += 1

    for i, c in enumerate(count):
        if c:
            tmp = output[i] / c
        else:
            tmp = np.zeros((3))

        output[i] = tmp.astype(np.uint8)
    return output


def mean_square_error(img, store, centroids):
    out = 0
    sx, sy = store.shape
    for i in range(sx):
        for j in range(sy):
            out += (img[i, j, :] - centroids[store[i, j]]) ** 2
    return sum(out)


def lbg_quantization(img, level_num, threshold, delta=None):
    if delta is None:
        delta = np.array([10, 10, 10])

    sx, sy, ch = img.shape
    centroids = init_centroid(img)

    store = np.zeros((sx, sy), dtype=np.uint8)

    while len(centroids) < level_num:
        centroids = add_centroids(centroids, delta)
        store = assign_image(img, centroids)
        mse = mean_square_error(img, store, centroids)
        while True:
            new_centroids = update_centroids(img, store, centroids)
            new_store = assign_image(img, new_centroids)
            new_mse = mean_square_error(img, new_store, new_centroids)

            if new_mse < threshold * mse:
                mse = new_mse
                store = new_store
                centroids = new_centroids
            else:
                break

    return centroids, store


def apply_lbg(centroids, store):
    sx, sy = store.shape
    out = np.zeros((sx, sy, 3), dtype=np.uint8)
    for i in range(sx):
        for j in range(sy):
            out[i, j, :] = centroids[store[i, j]]

    return out


def rainbow(centroids):
    return [np.random.randint(0, 256, (3), dtype=np.uint8) for _ in centroids]


def find_border(store, centr_count):

    sx, sy = store.shape
    for row in range(sy):
        prev = store[0, row]
        for i, v in enumerate(store[1:, row]):
            if v != prev:
                prev = v
                store[i, row] = centr_count
    for col in range(sx):
        prev = store[col, 0]
        for i, v in enumerate(store[col, 1:]):
            if v != prev:
                prev = v
                store[col, i] = centr_count


def low_pass_image(img, size):
    ker = np.ones((size, size)) / (size ** 2)
    return cv2.filter2D(img, -1, ker)


def main():
    img = low_pass_image(load_image(color=True), 3)
    centr, store = lbg_quantization(img, 8, 0.5)
    out = apply_lbg(centr, store)

    centr = rainbow(centr)
    # find_border(store, len(centr))
    # centr.append(np.zeros((3), dtype=np.uint8))

    bord = apply_lbg(centr, store)
    show_image(img, out, bord, wait=5)


if __name__ == "__main__":
    main()
