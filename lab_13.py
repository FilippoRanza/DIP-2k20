#! /usr/bin/python

# autogenerated on 2020-05-06 16:44

# Otsu binarization

import sys
from os import path

import cv2
import numpy as np
from matplotlib import pyplot as plt

from utils import *


def weighted_variance(hist, a, b):

    w = sum(hist[a:b])
    if w == 0:
        return None, None

    i = np.arange(a, b)
    tmp = np.sum((i * hist[a:b]) / w)
    v = np.sum(((i - tmp) ** 2) * (hist[a:b] / w))
    return w, v


def otsu_binarize(img):
    hist = get_histogram(img, False)
    size_x, size_y = img.shape
    pixels = size_x * size_y
    min_th = 0
    min_value = None
    for th in range(256):
        w_b, v_b = weighted_variance(hist, 0, th)
        w_f, v_f = weighted_variance(hist, th, 256)
        if w_b is None or w_f is None:
            continue

        err = (w_b * v_b) + (w_f * v_f)
        if min_value is None or min_value >= err:
            min_value = err
            min_th = th

    return min_th


def apply_threshold(img, *threshold):
    size_x, size_y = img.shape
    store = []
    for th in threshold:
        tmp = np.zeros((size_x, size_y), dtype=np.uint8)
        for i, row in enumerate(img):
            for j, v in enumerate(row):
                if v > th:
                    tmp[i, j] = 255
        store.append((f"Th = {th}", tmp))

    show_image(*store, wait=60)


def show_histogram(img, *threshold):
    h = get_histogram(img)
    m = max(h)
    plt.plot(h)
    for th in threshold:
        plt.plot([th, th], [0, m], color="r")
    plt.show()


def main():
    img = load_image_from_arg()
    th = otsu_binarize(img)
    correct, _ = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    print("Filippo", th)
    print("OpenCV", correct)

    show_histogram(img, th, correct)
    apply_threshold(img, th, correct)


if __name__ == "__main__":
    main()
